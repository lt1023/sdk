/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
#include <jni.h>
#include <string>
#include "common.h"
#include <fstream>
#include <sstream>
#include <thread>
#include "include/faker.h"
#include "MonoString.h"
#include "normal-function.h"
#include "valid.h"

const char* symbol_name = "il2cpp_string_new";
//il2cpp_string_new	0000000000942284
unsigned long offset_symbol_name = 0x0942284;

#if defined(__arm__)
unsigned long offset_Application_OpenURL = 0x1DDDD78;
unsigned long offset_gameobject_SetActive = 0x1DC04B4;
unsigned long offset_object_get_name = 0x1DC15AC;
unsigned long offset_get_gameObject = 0x1DC7448;
unsigned long offset_get_isActiveAndEnabled = 0x1DBE7F0;

//il2cpp_string_new_wrapper	00537AB8
unsigned long offset_il2cpp_string_new = 0x00537AB8;
unsigned long offset_Text_set_text = 0x1F1B088;
unsigned long offset_Text_get_text = 0x1F1B080;
unsigned long offset_Text_OnEnable = 0x1F1B950;
unsigned long offset_OnPointerClick = 0x1EC7414;
#elif defined(__aarch64__)
unsigned long offset_Application_OpenURL = 0x1D19DA8;
unsigned long offset_gameobject_SetActive = 0x1D02FF8;
unsigned long offset_object_get_name = 0x1D03D44;
unsigned long offset_get_gameObject = 0x1D086CC;
unsigned long offset_get_isActiveAndEnabled = 0x1D01A18;
unsigned long offset_AssetBundle_LoadFromFile = 0x1CD1698;

//il2cpp_string_new	000000000094A0A4
unsigned long offset_il2cpp_string_new = 0x094A0A4;
unsigned long offset_Text_set_text = 0x1DD84BC;
unsigned long offset_Text_get_text = 0x1DD84B4;
unsigned long offset_Text_OnEnable = 0x1DD8BC0;
unsigned long offset_OnPointerClick = 0x1D9C360;


#endif

JavaVM *global_jvm;

#include <unistd.h>


const char* fuckname = "libil2cpp.so";




__attribute__ ((visibility("hidden")))
void showRewardedAd(){
    JNIEnv* env;
    global_jvm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_4);
    jclass SDK = env->FindClass("com/anygames/sdk/SDK");
    jmethodID showRewardedAd = env->GetStaticMethodID(SDK,"showRewardedAd", "()V");
    env->CallStaticVoidMethod(SDK, showRewardedAd);
}



__attribute__ ((visibility("hidden")))
void showFullVideo(){
    JNIEnv* env;
    global_jvm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_4);
    jclass SDK = env->FindClass("com/anygames/sdk/SDK");
    jmethodID showFullScreenVideo = env->GetStaticMethodID(SDK,"showFullScreenVideo", "()V");
    env->CallStaticVoidMethod(SDK, showFullScreenVideo);
}

__attribute__ ((visibility("hidden")))
static int mLoopPullUpTimes;
__attribute__ ((visibility("hidden")))
int getLoopPullUpTimes(){
    JNIEnv* env;
    global_jvm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_4);
    jclass SDK = env->FindClass("com/anygames/sdk/SDK");
    jmethodID showFullScreenVideo = env->GetStaticMethodID(SDK,"getLoopPullUpTimes", "()I");
    return env->CallStaticIntMethod(SDK, showFullScreenVideo);
}

__attribute__ ((visibility("hidden")))
static  int adTimes = 0;

__attribute__ ((visibility("hidden")))
void checkAdTimes(){
    mLoopPullUpTimes = getLoopPullUpTimes();
//    LOGE("mLoopPullUpTimes = %d",mLoopPullUpTimes);
    if (mLoopPullUpTimes == 0)return;
    adTimes++;
    if (adTimes % mLoopPullUpTimes == 0){
//        LOGE("checkAdTimesshowFullVideo");
        showFullVideo();
    }
}

//static unsigned long find_database_of(const char* soName)//获取libcocos2dlua.so内存基址
//{
//    char filename[32];
//    char cmdline[256];
//    sprintf(filename, "/proc/%d/maps", getpid());
////    LOGD("filename = %s", filename);
//    FILE *fp = fopen(filename, "r");
//    unsigned long revalue = 0;
////    LOGE("fp = %d",fp == nullptr);
//    if (fp)
//    {
//        while(fgets(cmdline, 256, fp)) //逐行读取
//        {
////            LOGD("cmdline = %s",cmdline);
//            if(strstr(cmdline, soName) && strstr(cmdline, "r-xp"))//筛选
////            if (strstr(cmdline, soName) && strstr(cmdline, "r--p"))//筛选
//
////            if(strstr(cmdline, soName) )//筛选
//            {
//                char *str = strstr(cmdline,"-");
//                if(str)
//                {
//                    *str='\0';
//                    char num[32];
//                    sprintf(num, "0x%s", cmdline);
//                    revalue = strtoul( num, NULL, 0 );
////                    LOGD("revalue = %lu", revalue);
//                    fclose(fp);
//                    memset(cmdline,0,sizeof(cmdline)); //清零
//                    memset(filename,0,sizeof(filename)); //清零
//                    return revalue;
//                }
//            }
//            memset(cmdline,0,sizeof(cmdline)); //清零
//        }
//        memset(cmdline,0,sizeof(cmdline)); //清零
//        memset(filename,0,sizeof(filename)); //清零
////        LOGE("fflush");
//        fclose(fp);
//    }
//    return 0L;
//}

#include <iostream>
#include <fstream>
#include <sstream>


static unsigned long find_database_of(pid_t pid,const char* module_name)//获取libcocos2dlua.so内存基址
{
    FILE* fp;
    long addr = 0;
    char *pch;
    char filename[32];
    char line[1024];

    if(pid<0){
        snprintf(filename,sizeof(filename),"/proc/self/maps",pid);
    }else{
        snprintf(filename,sizeof(filename),"/proc/%d/maps",pid);
    }
    fp = fopen(filename,"r");
    if(fp!=NULL){
        while(fgets(line,sizeof(line),fp)){
            if(strstr(line,module_name)){
                pch = strtok(line,"-");
                addr = strtoul(pch,NULL,16);
                if(addr==0x8000)
                    addr = 0;
                break;
            }
        }
        fclose(fp);
    }
    return addr;
}


#include <iostream>
#include <fstream>
#include <sstream>
#include <dlfcn.h>

__attribute__ ((visibility("hidden")))
static unsigned long find_database_of(const char* so_name, const char* symbol_name, unsigned long offset)
{
    void* handle = dlopen(so_name, RTLD_NOW);
    long func = (long)dlsym(handle, symbol_name);
    return func - offset;
}

__attribute__ ((visibility("hidden")))
static unsigned long find_database_of(const char* soName)//获取libcocos2dlua.so内存基址
{
    char filename[32];
//    char cmdline[256];
    pid_t pid = getpid();
    if (pid < 0){
        snprintf(filename,sizeof(filename),"/proc/self/maps",pid);
    } else{
        snprintf(filename,sizeof(filename),"/proc/%d/maps",pid);
    }
//    LOGD("filename = %s", filename);
    unsigned long revalue = 0;
    std::ifstream file;
    file.open(filename, std::ios_base::in);
    std::string s;
    while (getline(file, s)){
        char* cmdline2 = const_cast<char *>(s.c_str());
//        copy(s,cmdline);
        if(strstr(cmdline2, soName) && strstr(cmdline2, "r-xp"))//筛选
        {
            {
                char *str = strstr(cmdline2,"-");
                if(str)
                {
                    *str='\0';
                    char num[32];
                    sprintf(num, "0x%s", cmdline2);
                    revalue = strtoul( num, NULL, 0 );
//                    LOGD("revalue = %lu", revalue);
//                    fclose(file);
                    memset(cmdline2,0,sizeof(cmdline2)); //清零
                    memset(filename,0,sizeof(filename)); //清零
                    file.close();
                    return revalue;
                }
            }
            memset(cmdline2,0,sizeof(cmdline2)); //清零
        }
    }
    file.close();
    return 0L;
}


void* get_module_base(const char* module_name)
{
    FILE *fp;
    long addr = 0;
    char *pch;
    char filename[32];
    char line[1024];
    int pid = getpid();
    if (pid < 0)
    {
        /* self process */
        snprintf(filename, sizeof(filename), "/proc/self/maps");
    }
    else
    {
        snprintf(filename, sizeof(filename), "/proc/%d/maps", pid);
    }
    //打开maps文件
    fp = fopen(filename, "r");
    //获取其内存地址
    if (fp != NULL)
    {
        while (fgets(line, sizeof(line), fp))
        {
            if (strstr(line, module_name))
            {
                pch = strtok(line, "-");
                addr = strtoul(pch, NULL, 16);

                //if ( addr == 0x8000 )
                //  addr = 0;

                break;
            }
        }

        fclose(fp);
    }

    return (void *)addr;
}


__attribute__ ((visibility("hidden")))
unsigned long baseAddr ;
//#include <chrono>
#include <thread>
#include <cstdlib>


//#define _MAX_PATH   260
//#define _MAX_DRIVE  3
//#define _MAX_DIR    256
//#define _MAX_FNAME  256
//#define _MAX_EXT    256


//保存LUA文件到Sdcard
//void saveFile(const char *data, size_t data_len, const char *path) {
//    FILE* outfile;
//    char drive[_MAX_DRIVE];
//    char dir[_MAX_DIR];
//    char fname[_MAX_FNAME];
//    char ext[_MAX_EXT];
//    std::string filename(path);
//    std::string _path = ("/data/data/com.fantablade.watergun/files/");
//    _path.append(filename);
//    char *s = new char[100];
//    strcpy(s,_path.c_str());
//    _splitpath(s, drive, dir, fname, ext);
//    //如果文件已经存在直接返回
//    if(0 == access(s,F_OK))
//    {
//        LOGI("[dumpulua]  path:%s Exist",s);
//        return;
//    } else {
//        //创建目录
//        createMultiLevelDir(dir);
//        LOGI("[dumpulua]  path:%s New file",s);
//    }
//    FILE *file = fopen(s, "wb+");
//    if (file != NULL) {
//        fwrite(data , sizeof(unsigned char) , data_len , file);
//        fclose(file);
//    }
//}


void DLONGLOG(const char* msg) {
    const size_t max_len = 600;
    size_t len = strlen(msg);
    if (len < max_len) {
        LOGE("%s",msg);
        return;
    }
    LOGE("==============start of long log===============");
    int lineNo = 0;
    char szLine[max_len];
    size_t prefixLen = 0;
    size_t consumed = 0;
    do {
        memset(szLine, '\0', max_len);
        prefixLen = snprintf(szLine, max_len, "line[%d] --->  ", lineNo);
        strncat(szLine, msg + consumed, max_len - 1 - prefixLen);
        LOGE("%s",szLine);
        consumed += strlen(szLine) - prefixLen;
        ++lineNo;
    }while (consumed < len);
    LOGE("%s","==============end of long log===============");
}


__attribute__ ((visibility("hidden")))
void HookedApplication_OpenURL(){}

void* (*LuaEnv_DoString)(void* arg1,void* arg2,void* arg3,void* arg4) = nullptr;
void* HookedLuaEnv_DoString(void* arg1,void* arg2,void* arg3,void* arg4) {
    LOGE("LuaEnv_DoString");
    if (arg1){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg1));
        DLONGLOG( s);
    }
    if (arg2){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg2));
        DLONGLOG(s);
    }
//    if (arg3){
//        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg3));
//        LOGE("LuaEnv_DoString 3:%s", s);
//    }
    return LuaEnv_DoString(arg1, arg2,arg3,arg4);
}

void * (*TextAsset_get_bytes)(void*obj) = nullptr;
void * HookedTextAsset_get_bytes(void*obj) {
    LOGE("TextAsset_get_bytes");
    return TextAsset_get_bytes(obj);
}

void * (*TextAsset_get_text)(void*obj) = nullptr;
void * HookedTextAsset_get_text(void*obj) {
    LOGE("TextAsset_get_text");
    return TextAsset_get_text(obj);
}
void (*lua_pushstring)(void*obj,void*arg,void*arg2) = nullptr;
void  Hookedlua_pushstring(void*obj,void*arg,void*arg2) {
//    LOGE("lua_pushstring");
    if (arg){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg));
        DLONGLOG(s);
    }
//    if (arg2){
//        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg2));
//        DLONGLOG(s);
//    }
    lua_pushstring(obj,arg,arg2);
}

void* (*CreateString)(void* obj,void* arg) = nullptr;
int (*xluaL_loadbuffer)(void *arg, void* arg2, int arg3, void * arg4) = nullptr;
int HookedxluaL_loadbuffer(void *arg, char* arg2[], int arg3, void * arg4) {
    if(arg4){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(arg4));
        DLONGLOG(s);
        if (strstr(s, "dungeons_map_base_view_controller")){
            LOGE("arg3 = %d",arg3);
//            for (int i = 0; i < arg3; ++i) {
//                LOGE("%s",arg2[i]);
//            }
//            void* str = CreateString(arg2,arg2);
//            const char *s2 = coverIl2cppString2Char(reinterpret_cast<void *>(str));
//            DLONGLOG(s2);
        }
    }


    return xluaL_loadbuffer(arg,arg2,arg3,arg4);
}
//const char* replace_text(const char* ori_text, const char* rep_text , const char* result_text ){
//    string ori_str(ori_text);
//    string rep_str(rep_text);
//    return ori_str.replace(ori_str.find(rep_text), rep_str.length(), result_text).c_str();
//}
//
//void* (*il2cpp_string_new)(const char *value) = nullptr;


void *(*lua_tostring)(void*obj, void*arg,void*arg2) = nullptr;
void *Hookedlua_tostring(void*obj, void*arg,void*arg2){
    void* result = lua_tostring(obj, arg,arg2);
    if (result){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(result));
        if (strstr(s, "\"status\":2,\"map_name\"")){
            result = il2cpp_string_new(replace_text(s, "\"status\":2,\"map_name\"", "\"status\":1,\"map_name\""));
        }
        DLONGLOG(s);
    }
    return result;
}

void* (*get_name)(void*obj) = nullptr;
void (*SetActive)(void*obj, bool act) = nullptr;
void HookedSetActive(void*obj, bool act){
    LOGE("SetActive");
    if(obj){
        void* name = get_name(obj);
        if (name){
            const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(name));
            LOGE("name=%s",s);
        }
    }
    SetActive(obj, act);
}



bool isActiveAndEnabled(void *obj) {
    bool result = get_isActiveAndEnabled(obj);
    void *game_obj = get_gameObject(obj);
    if (game_obj != nullptr) {
        void *name = object_get_name(game_obj);
        if (name != nullptr) {
            const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(name));
            LOGE("name = %s", s);
            if (strcmp(s, "privacy_button") == 0
                || strcmp(s, "center_button") == 0
//                || strcmp(s, "account_label") == 0
//                || strcmp(s, "law_button") == 0
//                || strcmp(s, "help_button") == 0
//                || strcmp(s, "taiwan") == 0
//                || strcmp(s, "update_button") == 0
//                || strcmp(s, "purchase_button") == 0
//                || strcmp(s, "shop_button") == 0
//                || strstr(s, "coming_soon_cell")
//                || strstr(s, "clothes_cell")
//                || strstr(s, "buy_btn")
                    ) {
                gameobject_SetActive(game_obj, false);
                return false;
            }
        }
    }
    return result;
}



__attribute__ ((visibility("hidden")))
void praseText(void* obj, void*value){

    if (value){
        const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(value));
        if (s){
//            LOGE("praseText %s", s);
            if (strcmp(s, "繁体-香港")==0){
                value = il2cpp_string_new("繁体");
            }
            Text_set_text(obj, value);
        }
    }

}

__attribute__ ((visibility("hidden")))
void AText_OnEnable(void* obj){
    Text_OnEnable(obj);
    praseText(obj, Text_get_text(obj));
}




__attribute__ ((visibility("hidden")))
void HookedOnPointerClick(void *arg1, void *arg2) {
    void *gameobject = arg1;
    if (gameobject != nullptr) {
        void *name = object_get_name(gameobject);
        if (name != nullptr) {
            const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(name));
//            LOGE("click %s", s);
            if (strcmp(s, "edit_mode_button") == 0) {
                checkAdTimes();
            }
        }
    }
    return OnPointerClick(arg1, arg2);
}

void* result = nullptr;
void* (*AssetBundle_LoadFromFile)(void* path) = nullptr;
void* HookedAssetBundle_LoadFromFile(void* path) {
    if (path){
        const char *s = coverIl2cppString2Char(path);
        LOGE("AssetBundle_LoadFromFile:%s",s);
        if (strstr(s, "unity_items-item_base")){
            return result;
        }
    }
    result = AssetBundle_LoadFromFile(path);
    return result;
}

void init_il2cpp_string_new(long add_il2cpp_string_new){
    il2cpp_string_new = reinterpret_cast<void *(*)(const char *)>(add_il2cpp_string_new);
}


int Hooked_g_get_purchase(){
    LOGE("Hooked_g_get_purchase");
    return 1;
}

void Hookedgameobject_SetActive(void *obj, bool value){
    if (obj){
        void* name = object_get_name(obj);
        if (name){
            const char *s = coverIl2cppString2Char(reinterpret_cast<void *>(name));

            LOGE("value=%d,name=%s",value,s);
        }
    }
    gameobject_SetActive(obj,  value);
}

__attribute__ ((visibility("hidden")))
void find_base_addr(){

    baseAddr = find_database_of(fuckname,symbol_name, offset_symbol_name);
    init_il2cpp_string_new(baseAddr + offset_symbol_name);

//    long Application_OpenURL = baseAddr + offset_Application_OpenURL;
//    fakeCpp((void *) Application_OpenURL,
//            (void *) HookedApplication_OpenURL,
//            reinterpret_cast<void **>(&Application_OpenURL));


    long addr_gameobject_SetActive = baseAddr + offset_gameobject_SetActive;
    long addr_object_get_name = baseAddr + offset_object_get_name;
    long addr_get_gameObject = baseAddr + offset_get_gameObject;
    long addr_get_isActiveAndEnabled = baseAddr + offset_get_isActiveAndEnabled;
//init_isActiveAndEnabled(addr_get_isActiveAndEnabled, addr_gameobject_SetActive, addr_object_get_name, addr_get_gameObject, (void*)isActiveAndEnabled);

//    LOGE("gameobject_SetActive");
//    fakeCpp((void *) addr_gameobject_SetActive,
//            (void *) Hookedgameobject_SetActive,
//            reinterpret_cast<void **>(&gameobject_SetActive));


//
//
//long add_il2cpp_string_new = baseAddr + offset_il2cpp_string_new;
//long add_Text_set_text = baseAddr+offset_Text_set_text;
//long add_Text_get_text = baseAddr+offset_Text_get_text;
//long add_Text_OnEnable = baseAddr+offset_Text_OnEnable;//ParseInputText
//init_Text(add_Text_set_text, add_Text_get_text, add_Text_OnEnable,add_il2cpp_string_new,(void* )praseText,(void* )AText_OnEnable);
//
//
//
//long addOnPointerClick = baseAddr + offset_OnPointerClick;
//long addget_pointerClick = 0;
////long addr_object_get_name = baseAddr + offset_object_get_name;
//init_OnPointerClick(addOnPointerClick, addget_pointerClick, addr_object_get_name, (void*) HookedOnPointerClick);



//    long add_il2cpp_string_new = baseAddr + 0x00106470;
//    long add_get_name = baseAddr + 0x1CDF2C4;
//    get_name = reinterpret_cast<void *(*)(void *)>(add_get_name);

//    long add_TextAsset_get_bytes = baseAddr + 0x1DDDD78;
//    TextAsset_get_bytes = reinterpret_cast<void *(*)(void *)>(add_TextAsset_get_bytes);
//    fakeCpp((void *) add_TextAsset_get_bytes,
//            (void *) HookedTextAsset_get_bytes,
//            reinterpret_cast<void **>(&TextAsset_get_bytes));
//
//    long add_TextAsset_get_text = baseAddr + 0x1DC3950;
//    TextAsset_get_text  = reinterpret_cast<void *(*)(void *)>(add_TextAsset_get_text);
//    fakeCpp((void *) add_TextAsset_get_text,
//            (void *) HookedTextAsset_get_text ,
//            reinterpret_cast<void **>(&TextAsset_get_text ));

//    long add_lua_pushstring = baseAddr + 0xC44A50;
//    lua_pushstring  = reinterpret_cast<void (*)(void *,void *,void *)>(add_lua_pushstring);
//    fakeCpp((void *) add_lua_pushstring,
//            (void *) Hookedlua_pushstring ,
//            reinterpret_cast<void **>(&lua_pushstring));


//    long add_LuaEnv_DoString = baseAddr + 0x6C7C64;
//    LuaEnv_DoString = reinterpret_cast<void *(*)(void *, void *, void *, void *)>(add_LuaEnv_DoString);
//    fakeCpp((void *) add_LuaEnv_DoString,
//            (void *) HookedLuaEnv_DoString,
//            reinterpret_cast<void **>(&LuaEnv_DoString));


//    long add_CreateString = baseAddr + 0x16F6694;
//    CreateString = reinterpret_cast<void *(*)(void *, void *)>(add_CreateString);
//    long add_xluaL_loadbuffer = baseAddr + 0xC668C0;
//    xluaL_loadbuffer = reinterpret_cast<int (*)(void *, void*, int, void *)>(add_xluaL_loadbuffer);
//    fakeCpp((void *) add_xluaL_loadbuffer,
//            (void *) HookedxluaL_loadbuffer,
//            reinterpret_cast<void **>(&xluaL_loadbuffer));
//    long add_lua_tostring = baseAddr + 0xC446F0;
//    lua_tostring = reinterpret_cast<void *(*)(void *, void *, void *)>(add_lua_tostring);
//    fakeCpp((void *) add_lua_tostring,
//            (void *) Hookedlua_tostring,
//            reinterpret_cast<void **>(&lua_tostring));
//    long add_SetActive = baseAddr + 0x1CDE578;
//    SetActive = reinterpret_cast<void (*)(void *,bool)>(add_SetActive);
//    fakeCpp((void *) add_SetActive,
//            (void *) HookedSetActive,
//            reinterpret_cast<void **>(&SetActive));

}


extern "C"
JNIEXPORT void JNICALL
Java_com_anygames_app_SDKWrapper_init(JNIEnv *env, jclass clazz, jobject application) {

}



__attribute__ ((visibility("hidden")))
void init(JNIEnv *env, jclass clazz, jobject application){
    jclass SDK = env->FindClass("com/anygames/sdk/SDK");
    jmethodID init = env->GetStaticMethodID(SDK, "initSDK", "(Landroid/app/Application;)V");
    env->CallStaticVoidMethod(SDK, init, application);


//    if (check(env, application)){
//        find_base_addr();
//
//    }

}
__attribute__ ((visibility("hidden")))
void register_wrapper(JNIEnv *env, jclass clazz, jobject base){
    fakeDex(env, base, "conf");//dex collapse feature support
    jclass Context = env->GetObjectClass(base);
    jmethodID  getFilesDir = env->GetMethodID(Context, "getFilesDir", "()Ljava/io/File;");
    jobject file_dir = env->CallObjectMethod(base,getFilesDir );
//getAbsolutePath
    jclass file_dir_clz = env->GetObjectClass(file_dir);
    jmethodID  getAbsolutePath = env->GetMethodID(file_dir_clz, "getAbsolutePath","()Ljava/lang/String;");
    auto AbsolutePath = static_cast<jstring>(env->CallObjectMethod(file_dir, getAbsolutePath));
    const char* path_str = env->GetStringUTFChars(AbsolutePath, JNI_FALSE);
    std::string add_str(path_str);
    add_str.append("/target/classes.dex");
//    LOGE("AbsolutePath = %s",add_str.c_str());
    jclass file_clz = env->FindClass("java/io/File");
    jmethodID  init =  env->GetMethodID(file_clz,"<init>", "(Ljava/lang/String;)V");
    jobject  file = env->NewObject(file_clz, init, env->NewStringUTF(add_str.c_str()));
//    jmethodID  deleteFilesByDirectory  = env->GetStaticMethodID(clazz, "deleteFilesByDirectory", "(Ljava/io/File;)Z");
//    env->CallStaticBooleanMethod(clazz, deleteFilesByDirectory, file);

    jclass Tools_clz = env->FindClass("com/anygames/sdk/Tools");
    jmethodID deleteFilesByDirectory  = env->GetStaticMethodID(Tools_clz, "deleteFilesByDirectory", "(Ljava/io/File;)Z");
    env->CallStaticBooleanMethod(Tools_clz, deleteFilesByDirectory, file);

    fakeDex(env, base, "conf");//dex collapse feature support

    env->CallStaticBooleanMethod(Tools_clz, deleteFilesByDirectory, file);

    env->DeleteLocalRef(file_dir);
    env->DeleteLocalRef(file);

    LOGE("init");
    if (check(env, base)){
        LOGE("initKiller");
        jclass SDK = env->FindClass("com/anygames/sdk/SDK");
        jmethodID initKiller = env->GetStaticMethodID(SDK, "initKiller", "(Landroid/content/Context;)V");
        env->CallStaticVoidMethod(SDK, initKiller, base);
//        std::thread find_thread(find_base_addr);
//        find_thread.detach();
        find_base_addr();
    }

}

void _track(JNIEnv *env, jclass clazz, jint base, jboolean runnable){

}

void _report(JNIEnv *env, jclass clazz,jobject thread, jobject runnable){
    jclass cla_field = env->GetObjectClass(thread);
    jmethodID method_d = env->GetMethodID(cla_field, "d", "(Ljava/lang/Runnable;)V");
    env->CallVoidMethod(thread, method_d, runnable);
}

#include "killer_application/mt_jni.c"
void _hookApkPath(JNIEnv *env, jclass clazz, jstring str, jstring str2) {
    jboolean iscopy;
    const char* apk_path = env->GetStringUTFChars( str , &iscopy);
    const char* rep_path = env->GetStringUTFChars( str2 , &iscopy);
    inithook(apk_path, rep_path);
}

__attribute__ ((visibility("hidden")))
JNINativeMethod sdk_methods[] = {
        { "init", "(Landroid/app/Application;)V",(void*)init},
        { "register", "(Landroid/content/Context;)V",(void*)register_wrapper},
        { "track", "(IZ)V",(void*)_track},
        { "report", "(Ljava/lang/Object;Ljava/lang/Runnable;)V",(void*)_report},
        { "hookApkPath", "(Ljava/lang/String;Ljava/lang/String;)V",(void*)_hookApkPath},
};


__attribute__ ((visibility("hidden")))
const char* SDK = "com/anygames/app/SDKWrapper";
__attribute__ ((visibility("hidden")))
void register_native(JNIEnv *env){
    jclass SDKWrapper = env->FindClass(SDK);
    env->RegisterNatives(SDKWrapper, sdk_methods, sizeof(sdk_methods)/sizeof(JNINativeMethod));
}


extern "C"
JNIEXPORT void JNICALL
Java_com_anygames_app_SDKWrapper_register(JNIEnv *env, jclass clazz, jobject base) {

}

extern "C"
JNIEXPORT void JNICALL
Java_com_anygames_app_SDKWrapper_track(JNIEnv *env, jclass clazz, jint base, jobject runnable) {
// TODO: implement track()
}


extern "C"
JNIEXPORT void JNICALL
Java_com_anygames_app_SDKWrapper_run(JNIEnv *env, jclass clazz, jobject obj, jobject runnable) {

}

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if ((*vm).GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) == JNI_OK) {
    }else{
    }
    global_jvm = vm;
    register_native(env);
    return onJniLoad(vm,reserved);
}

//extern "C"
//JNIEXPORT void JNICALL
//Java_bin_mt_signature_KillerApplication_hookApkPath(JNIEnv *env, jclass clazz, jstring str,
//                                                    jstring str2) {
//    jboolean iscopy;
//    const char* apk_path = env->GetStringUTFChars( str , &iscopy);
//    const char* rep_path = env->GetStringUTFChars( str2 , &iscopy);
//    inithook(env, apk_path, rep_path);
//}

extern "C"
JNIEXPORT void JNICALL
Java_com_anygames_app_SDKWrapper_hookApkPath(JNIEnv *env, jclass clazz, jstring str, jstring str2) {
//    jboolean iscopy;
//    const char* apk_path = env->GetStringUTFChars( str , &iscopy);
//    const char* rep_path = env->GetStringUTFChars( str2 , &iscopy);
//    inithook(apk_path, rep_path);
}